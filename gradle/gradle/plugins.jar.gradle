// Generic gradle script for 'pluginJar' task
// This script MUST be embedded by plugins; do not embed in root project!

// Can be embedded in build.gradle using 
//    apply from: 'core/gradle/gradle/plugins.jar.gradle'

repositories {
	mavenCentral()
}

configurations {
	pluginjar
	pluginjar_linux_x86
	pluginjar_linux_x86_64
	pluginjar_windows_x86
	pluginjar_windows_x86_64
	pluginjar_macosx_x86
	pluginjar_macosx_x86_64
}

project.ext {
	pluginOperatingSystem = (System.properties['os']) ? System.properties['os'] : "all"
	pluginArchitecture = (System.properties['arch']) ? System.properties['arch'] : "all"	
	pluginOperatingSystemAndArchitectureAvailable = System.properties['os'] && System.properties['arch']
}

processResources {	
	from(source) {
		include "**/*.properties", "**/*.xml"
		filter{ String line -> line.replaceAll('%pluginId%', "${pluginId}") }        	            
		filter{ String line -> line.replaceAll('%pluginName%', "${pluginName}") }        	            
		filter{ String line -> line.replaceAll('%pluginVersion%', "${pluginVersionFull}") }      	            
		filter{ String line -> line.replaceAll('%pluginOperatingSystem%', "${pluginOperatingSystem}") }  
		filter{ String line -> line.replaceAll('%pluginArchitecture%', "${pluginArchitecture}") }  				
		filter{ String line -> line.replaceAll('%pluginDate%', "${pluginDate}") }    	
		filter{ String line -> line.replaceAll('%pluginAppMinVersion%', "${pluginAppMinVersion}") }    	
		filter{ String line -> line.replaceAll('%pluginRelease%', "${pluginRelease}") }    	
		filter{ String line -> line.replaceAll('%pluginConflictsWith%', "${pluginConflictsWith}") }    	
	}
}		

task pluginJar(type: Jar, dependsOn: [processResources, compileJava]) {
	if (project.ext.has('pluginNeedsOperatingSystemAndArchitecture')) {
		if (pluginNeedsOperatingSystemAndArchitecture && !pluginOperatingSystemAndArchitectureAvailable) {
			throw new Exception("Operating system / architecture dependent plugin, but OS/arch information not available; pass via -Dos=(linux|windows|macosx) and -Darch=(x86|x86_64)");
		}
	}
	
	from files(sourceSets.main.output.classesDir)
	from files(sourceSets.main.output.resourcesDir)
	from { 
		configurations.pluginjar.collect { 
			zipTree(it)
		}
	}
	from {
		if (pluginOperatingSystemAndArchitectureAvailable) {
			configurations["pluginjar_" + pluginOperatingSystem + "_" + pluginArchitecture].collect { 
				zipTree(it)
			}		
		}
	}
	exclude "META-INF/*.RSA", "META-INF/*.SF", "META-INF/*.DSA" 
	
	// The exclude statement ignores detached signatures from other
	// dependencies (JARs) and leaves them out when combining to one JAR
	
	if (pluginOperatingSystemAndArchitectureAvailable) {
		baseName = "syncany-plugin-${pluginId}-${pluginOperatingSystem}-${pluginArchitecture}"
		version  = "${pluginVersionFull}"
	}
	else {
		baseName = "syncany-plugin-${pluginId}"
		version  = "${pluginVersionFull}"
	}
	
	manifest {
		attributes("Plugin-Id": "${pluginId}")
		attributes("Plugin-Name": "${pluginName}")
		attributes("Plugin-Version": "${pluginVersionFull}")
		attributes("Plugin-Operating-System": "${pluginOperatingSystem}")
		attributes("Plugin-Architecture": "${pluginArchitecture}")			
		attributes("Plugin-Date": "${pluginDate}")		
		attributes("Plugin-App-Min-Version": "${pluginAppMinVersion}")		
		attributes("Plugin-Release": "${pluginRelease}")		
		attributes("Plugin-Conflicts-With": "${pluginConflictsWith}")			
	}						
}
